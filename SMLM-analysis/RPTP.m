%% function RPTP(loc, hs, oldName, addsfx, varargin)
%**************************************************************************
% RPTP = version 2.0 of returnPicassotoPicasso function. This version is
% upgraded to handle all Picasso output formats (2d/3d/merged) and to
% optionally edit the yaml file
%
% This code allows you to take information in the specific structure of a
% Picasso hdf5 file and export it to an hdf5 that can be read into Picasso.
% This was written with the intent of doing dualview corrections and bead
% alignment in MATLAB and then returning the data to Picasso to link
% localizations. 
% --REQUIRED INPUTS
% --loc = the loc output from ADL's Omniloader. Used to set dimensions of the
%   dataset in the hdf5 file and to copy the data over to the new hdf5 file
% --hs = headerstring from Omniloader, needed to set columns
% --oldName = a string of the hdf5 file that the data comes from without the
%   extension. e.g. if the file is 'localizations.hdf5' then oldName = 'localizations'
% --addsfx = a string that you want to append to the old name, ie
% '_filter'. So as above, you'd get 'localizations_filter.hdf5' as the
% output. This will get overruled if 'changename' is defined
% --OPTIONAL INPUTS (name/value pairs)
% --yamlupdate = semicolon separated strings to update the yaml
%   file as desired, ie  {'Generated by: Matlab filtering';'Photon cutoff: 1500';'Sigma cutoff: 2';'lpx cutoff: 15'};
%   lines need to be 'something: something'; the colon is important. Note
%   that yes I understand this is a shitty way to edit yaml files - ADL
% --widthupdate = if you are merging left and right of DUV localization
%   files the yaml will not update to be the full width and picasso will not behave right. 
%   specify 'widthupdate',(full width) so render works right. 
% --changename = char to change the filename too, ie
%   RPTP(...'changename','newNameIwant') without an extension will rename the
%   saved file to 'newNameIwant.hdf5'
% --changepath = char full path to change save path to. ie
% RPTP(...'changeName','newFile','changepath','X:/Aaron/test/') will save
% the hdf5/yaml to changepath. Similarly works without changename and will
% add the suffix
%
% Original RPTP adapted by PD 07.21.21
% Edited by ADL 1/2022 to work for any Picasso file type and added QOL +
% YAML editing
% fixed groups field not being an integer bug 4/25/22 ADL
% edited ADL 5/6/22 to handle full paths or just filenames with both addsfx
% and changename
% edited ADL 5/16/22 to make it not reorder columns (ie fixed the great "oh
% god photons are column 6 now?" problem 2k22) (ie the order of locs is now
% based on column number, not the order of the col struct)
% edited ADL 4/24/23 to add changepath
%  This file is intended for use with HDF5 Library version 1.8
%**************************************************************************
function RPTP(loc, hs, oldName, addsfx, varargin)

% hack some inputs
p = inputParser;
addRequired(p,'loc',@isnumeric);
addRequired(p,'hs',@ischar);
addRequired(p,'oldName',@ischar);
addRequired(p,'addsfx',@ischar);
addParameter(p,'yamlupdate','',@iscell);
addParameter(p,'widthupdate',0,@isnumeric);
addParameter(p,'changename','',@ischar)
addParameter(p,'changepath','',@ischar)
parse(p,loc,hs,oldName,addsfx,varargin{:});

loc = p.Results.loc;
if isempty(p.Results.changename) && isempty(p.Results.changepath)
    newName = [p.Results.oldName p.Results.addsfx];
elseif isempty(p.Results.changename) && ~isempty(p.Results.changepath)
    newName = fullfile(p.Results.changepath, [p.Results.oldName p.Results.addsfx]);
elseif ~isempty(p.Results.changename) && isempty(p.Results.changepath)
    [folder,~,~] = fileparts(p.Results.oldName);
    newName = fullfile(folder, p.Results.changename);
elseif ~isempty(p.Results.changename) && ~isempty(p.Results.changepath)
    newName = fullfile(p.Results.changepath, p.Results.changename);
end
fileName = [newName '.hdf5'];


% Initialized some variables
DATASET = 'locs';
DIM0 = size(loc,1);
dims = DIM0;

% Turn the input array into a struct
col = getColumns(p.Results.hs);
if min(loc(:,col.frame))==1  % Zero frame number for picasso 0 index
   loc(:,col.frame) = loc(:,col.frame)-1; 
end
if isempty(col.z)
    col = rmfield(col,'z');
end
% sort col to be in order of column number added 5/16/22
[~,idx] = sort(structfun(@(x) x, col),'ascend');
col = orderfields(col, idx);

%initiate things to make the locs struct
locnames = fieldnames(col);
sizeCol = length(locnames);
locs = struct;
headers = strsplit(p.Results.hs,',');
    
for thisname = 1:sizeCol
     % this bit is here to make the locs struct have same names as Picasso
     % output rather than what getColumns titles them. The strsplit is to
     % crop off an [px] or [nm] added.
    name = headers{col.(locnames{thisname})};
    name = strsplit(name);
    name = name{1}; 
    locs.(name) = loc(:,col.(locnames{thisname}));
end
locs.frame = uint32(locs.frame); % frames should be integers while other columns are double
if any(ismember(locnames,'groups'))
    locs.group = uint32(locs.group);
end
if any(ismember(locnames,'n'))
    locs.n = uint32(locs.n);
end
if any(ismember(locnames,'len'))
    locs.len = uint32(locs.len);
end

% Create a new file using the default properties.
file = H5F.create(fileName, 'H5F_ACC_TRUNC','H5P_DEFAULT', 'H5P_DEFAULT');

%Create the required data types
intType = H5T.copy('H5T_NATIVE_INT');
doubleType = H5T.copy('H5T_NATIVE_DOUBLE');
names = fieldnames(locs);
sizelocs = length(names);
sz = nan(1,sizelocs);
for thisfield = 1:sizelocs
    if isa(locs.(names{thisfield}),'uint32')
        sz(thisfield) = H5T.get_size(intType);
    elseif isa(locs.(names{thisfield}),'double')
        sz(thisfield) = H5T.get_size(doubleType);
    end
end

% Compute the offsets for each field. The first offset is always zero.
offset(1) = 0;
offset(2:sizelocs) = cumsum(sz(1:sizelocs-1));

% Create the compound datatype for memory.
memtype = H5T.create('H5T_COMPOUND', sum(sz));
for i = 1:sizelocs
    if isa(locs.(names{i}),'uint32')
         H5T.insert(memtype,names{i},offset(i),intType);
    elseif isa(locs.(names{i}),'double')
         H5T.insert(memtype,names{i},offset(i),doubleType);
    end
end

% Create the compound datatype for the file.  Because the standard
% types we are using for the file may have different sizes than
% the corresponding native types, we must manually calculate the
% offset of each member.
filetype = H5T.create('H5T_COMPOUND', sum(sz));
for i = 1:sizelocs
    if isa(locs.(names{i}),'uint32')
        H5T.insert(filetype, names{i}, offset(i),intType);
    elseif isa(locs.(names{i}),'double')
        H5T.insert(filetype,names{i},offset(i),doubleType);
    end
end

% Create dataspace.  Setting maximum size to [] sets the maximum
% size to be the current size.
space = H5S.create_simple(1,fliplr(dims), []);

% Create the dataset and write the compound data to it.
dset = H5D.create(file, DATASET, filetype, space, 'H5P_DEFAULT');
H5D.write(dset, memtype, 'H5S_ALL', 'H5S_ALL', 'H5P_DEFAULT', locs);

% Close and release resources.
H5D.close(dset);
H5S.close(space);
H5T.close(filetype);
H5F.close(file);

% Create the yaml file needed for picasso - this is a shit hack to edit the
% yaml file as text, but it does work. This way you can add info to keep a
% log of changes made in ML
yamldata = importdata([p.Results.oldName '.yaml'],'\n');

if p.Results.widthupdate ~= 0 % update widths for merged files
    wline = contains(yamldata,'Width');
    if sum(wline)>1 % block deals with width row from umanager metadata and replaces only picasso width
        lines = yamldata(wline);
        l = find(wline==1);
        test = cellfun(@isempty,regexp(lines,'^\s'));
        l = l(~test);
        wline(l) = 0;
    end
    newwidth = ['Width: ' num2str(p.Results.widthupdate)];
    yamldata{wline} = newwidth;
end
if ~isempty(p.Results.yamlupdate) % add filter data as needed
    yamldata = [yamldata;'---';p.Results.yamlupdate];
end
% rewrite the yaml file
if exist('writecell') == 0
    T = cell2table(yamldata(1:end,:)); % deals with ml2018 and earlier
    writetable(T,[newName '.txt'],'WriteVariableNames',0)
elseif exist('writecell') ~= 0
    if contains(version, '2022a')==0
        writecell(yamldata,[newName '.txt'],'QuoteStrings',0)
    elseif contains(version, '2022a')==1
        writecell(yamldata,[newName '.txt'],'QuoteStrings','none')
    end
end
copyfile([newName '.txt'], [newName '.yaml'])
delete([newName '.txt'])

end %fxn
